import os
import re
import json
from Validation import AcrossValidation
from Implementation.Logic import AcrossEntry

from docx import Document
from docx.shared import Cm
from docx.shared import Pt
from Abstract.IAcrossReader import IAcrossReader


class AcrossReader(IAcrossReader):

    def __init__(self):
        super().__init__()
        self.across_validator = AcrossValidation.AcrossValidation()

    def read_htm_file(self, htm_file, tag_file):
        """
        Reads a file in htm format that is generated by Across and converts the text a docx file.
        """

        try:
            # Validation
            self.across_validator.validate_file_existence(htm_file)
            self.across_validator.validate_file_existence(tag_file)
            self.across_validator.check_file_ending(htm_file)
            self.across_validator.check_across_htm_file(htm_file)
            self.across_validator.check_tag_file(tag_file)

            all_tags_from_tag_file = self.__transform_json_to_dict(tag_file)

            if not self.across_validator.validate_json_schema(all_tags_from_tag_file):
                return False

            file_to_store = self.__generate_destination_file(htm_file)

            with open(htm_file, "r", encoding="utf-8") as file_to_be_read:
                lines = file_to_be_read.readlines()
                counter = 1
                translations = list()
                source = ''

            for line in lines:
                if line.startswith("<DIV id=contents"):
                    if counter == 2:
                        source = self.__process_line_source(line[:-1], all_tags_from_tag_file)
                        counter += 1

                    elif counter == 3:
                        translation = self.__process_line_translation(line, all_tags_from_tag_file)
                        counter = 1
                        translation_entry = AcrossEntry.AcrossEntry(segment_id, source, translation)
                        translations.append(translation_entry)

                if 'inactiveNumbering" width=' in line and counter == 1:
                    segment_id = AcrossReader.__process_segment_id(line)
                    counter += 1

            translations_without_duplicates = self.__remove_duplicates(self, translations)

            self.write_file_to_docx(translations_without_duplicates, file_to_store)
            return True

        except (OSError, FileExistsError, ValueError) as error:
            raise ValueError(error)

    def __process_line_source(self, line, tags_dictionary):
        source = line
        source = self.__remove_nbsp_tag(source)
        source = self.__remove_tags_inline(source, tags_dictionary)
        source = self.__replace_special_characters(source)
        return source

    def __process_line_translation(self, line, tags_dictionary):
        translation = self.__remove_nbsp_tag(line)
        translation = self.__remove_tags_inline(translation, tags_dictionary)
        translation = self.__replace_special_characters(translation)
        return translation

    @staticmethod
    def __process_segment_id(line):
        segment_id = re.sub('<TD.*?MARGIN: 2px 0px 0px"><SPAN class=atom>', "", line)
        segment_id = re.sub("</SPAN></PRE></TD>", "", segment_id)[:-1]
        return segment_id

    @staticmethod
    def __remove_duplicates(self, translation_list):
        """
        Removes entries that occur multiple times in a given list containing translation entries (consist segment id,
        source text, and translation.

        :param translation_list: list containing all translations of the text. The entries are instances of the class
        AcrossEntry.
        :return: list holding translations without duplicates.
        """

        list_without_duplicates = list()

        for entry in translation_list:
            entry_exists = False
            for entry_without_duplicates in list_without_duplicates:
                if entry_without_duplicates.source == entry.source:
                    entry_exists = True
                    break

            if entry_exists is False:
                list_without_duplicates.append(entry)

        return list_without_duplicates

    def __remove_tags_inline(self, line, tag_dict):
        """
        Removes tags that occur within the text and removes them or replaces them with responding tags that are
        defined in a json file.

        :param line: one segment holding the source text or the translation.
        :return: line with customized tags (replaced or removed).
        """

        # default tags that are used in every htm file that is generated by Across
        line_cleaned = re.sub("<WBR>", "", line)
        line_cleaned = re.sub("<TR.*?>", "", line_cleaned)
        line_cleaned = re.sub("<TD.*?>", "", line_cleaned)
        line_cleaned = re.sub("<DIV.*?>", "", line_cleaned)
        line_cleaned = re.sub("<PRE.*?>", "", line_cleaned)
        line_cleaned = re.sub("<SPAN.*?>", "", line_cleaned)
        line_cleaned = re.sub("</SPAN>", "", line_cleaned)
        line_cleaned = re.sub("</PRE>", "", line_cleaned)
        line_cleaned = re.sub("</DIV>", "", line_cleaned)
        line_cleaned = re.sub("</TD>", "", line_cleaned)
        line_cleaned = re.sub("</TR>", "", line_cleaned)

        for tag in tag_dict.get('data'):
            line_cleaned = self.__replace_tag(line_cleaned, tag.get('name'), tag.get('show_tag'), tag.get('opening'), tag.get('closing'))

        line_cleaned = re.sub('<IMG.*?alt="<Pfad>.*?</Pfad>.*?">', "<Pfad />", line_cleaned)
        line_cleaned = re.sub('<IMG.*?png">', "", line_cleaned)

        return line_cleaned

    def save_to_tag_file(self, tag_list, tag_file):
        """
        Stores a new tag in the tag file in case the tag is still not existing in the file.

        :param tag_list: information of the new tag that is to be stored.
        :param tag_file: json file that contains at least an empty dictionary.
        :return: Success / Failure messages.
        """

        tags_dictionary = self.__transform_json_to_dict(tag_file)

        for entry in tags_dictionary.__getitem__('data'):
            if entry.get('name') == tag_list[0].get():
                return False

        new_tag = {"name": tag_list[0].get(),
                    "show_tag": tag_list[3].get(),
                    "opening": tag_list[1].get(),
                    "closing": tag_list[2].get()
                    }

        tags_dictionary.__getitem__('data').append(new_tag)

        with open(tag_file, 'w', encoding='utf-8') as file:
            json.dump(tags_dictionary, file, indent=2)

        return True

    @staticmethod
    def create_new_tag_file(tag_file_path):
        """
        Creates a new json file containing an empty dictionary.

        :param tag_file_path: path of the tag file that is to be stored.
        """

        new_tags_dictionary = {'data': []}

        with open(tag_file_path, "w", encoding="utf-8") as file:
            json.dump(new_tags_dictionary, file, indent=2)

    @staticmethod
    def show_tags(tag_file):
        """
        Returns a list of all tags given in the tag file.

        :param tag_file: json file that contains at least on empty dictionary.
        :return: list of tags that are stored in the tag file.
        """

        tag_list = list()
        tags_dictionary = AcrossReader.__transform_json_to_dict(tag_file)

        for tag in tags_dictionary.get('data'):
            if tag.get('closing') == "":
                element_to_insert = f"{tag.get('name')}: {tag.get('show_tag')}, {tag.get('opening')}, --"
            else:
                element_to_insert = f"{tag.get('name')}: {tag.get('show_tag')}, {tag.get('opening')}, {tag.get('closing')}"
            tag_list.append(element_to_insert)

        return tag_list

    @staticmethod
    def __replace_tag(line, tag_name, show_tag, opening, closing):
        """
        Replaces all the tags with the given opening and closing tag as it is used in the source text.
        The tags that should be considered is stored in a json file that supports UTF 8 encoding. If the show_tag is
        set to false, the tag will be removed and not replaced by any defined name.

        :param line: line to be considered.
        :param tag_name: name that should appear in the cleaned file.
        :param show_tag: determines whether the tag should be replaced (true) or removed (false).
        :param opening: opening tag as it is used in the source document.
        :param closing: closing tag as it is used in the source document. If there is no closing tag, it needs to be
        set to an empty string "".
        :return: line that replaced / removed the tags according to the information in the json file.
        """

        counter = line.count(opening)
        counter_closing = line.count(closing)
        if counter == counter_closing:
            for occurrence in range(0, counter):
                if show_tag:
                    line = re.sub(f'<IMG.*?alt="{opening}".*?">', f"<{tag_name}>", line, 1)
                else:
                    line = re.sub(f'<IMG.*?alt="{opening}".*?">', '', line, 1)

                if "" != closing:
                    if show_tag:
                        line = re.sub(f'<IMG.*?alt="{closing}".*?">', f"</{tag_name}>", line, 1)
                    else:
                        line = re.sub(f'<IMG.*?alt="{closing}".*?">', '', line, 1)
        else:
            for occurrence in range(0, counter):
                if show_tag:
                    line = re.sub(f'<IMG.*?alt="{opening}".*?">', f"<{tag_name}>", line, 1)
                else:
                    line = re.sub(f'<IMG.*?alt="{opening}".*?">', '', line, 1)

            for occurrence in range(0, counter_closing):
                if "" != closing:
                    if show_tag:
                        line = re.sub(f'<IMG.*?alt="{closing}".*?">', f"</{tag_name}>", line, 1)
                    else:
                        line = re.sub(f'<IMG.*?alt="{closing}".*?">', '', line, 1)
        return line

    @classmethod
    def __replace_special_characters(cls, translation_string):
        """
        Replaces "&lt;" and "&gt;" with their encoded symbols.

        :param translation_string: one segment holding the source text or the translation.
        :return: string that replaced "&lt;" and "&gt;" with "<" and ">".
        """

        translation_string_cleaned = re.sub("&lt;", "<", translation_string)
        translation_string_cleaned = re.sub("&gt;", ">", translation_string_cleaned)
        return translation_string_cleaned

    @classmethod
    def __remove_nbsp_tag(cls, translation_string):
        """
        Removes whitespace tags within the translation.

        :param translation_string: one segment holding the source text or the translation.
        :return: segment without any whitespace tags
        """

        if 'class=field alt=&amp;nbsp; src=' in translation_string:
            translation_string_cleaned = re.sub('</SPAN>.*?<SPAN class=atom>', ' ', translation_string)
            return translation_string_cleaned
        elif '&nbsp;' in translation_string:
            translation_string_cleaned = re.sub('&nbsp;', '', translation_string)
            return translation_string_cleaned
        else:
            return translation_string

    def delete_tag(self, tag_file, tag_to_be_deleted):
        """
        Deletes an existing tag in the given file.

        :param tag_file: json file that contains at least an empty dictionary.
        :param tag_to_be_deleted: tag that needs to be deleted.
        :return: Success / Failure message.
        """

        try:
            self.across_validator.check_empty_string(tag_to_be_deleted.get())
            tags_dictionary = self.__transform_json_to_dict(tag_file)

            new_tags_dictionary = {'data': []}
            entry_exists = False

            for entry in tags_dictionary.__getitem__('data'):
                if entry.get('name') != tag_to_be_deleted.get():
                    new_tags_dictionary.__getitem__('data').append(entry)
                else:
                    entry_exists = True

            if entry_exists:
                with open(tag_file, 'w', encoding='utf-8') as file:
                    json.dump(new_tags_dictionary, file, indent=2)
                return True

            else:
                return False

        except ValueError as error:
            return False

    @classmethod
    def __generate_destination_file(cls, path):
        """
        Creates the path of the file where the processed file is to be stored. The suffix '_translated' will be added
        to the destination file automatically.

        :param path: path of the source file.
        :return: path of the destination file.
        """

        directory_name = os.path.dirname(path) + "/"
        file_name = os.path.basename(path)
        file_name = file_name.split('.')[0]
        file_name_translation = file_name + ".docx"
        path_translation = directory_name + file_name_translation

        return path_translation

    @staticmethod
    def __transform_json_to_dict(json_file):
        """
        Reads a json file and returns the content in a dictionary.

        :param json_file: json file that is to be stored as a dictionary.
        :return: content of the json file in a dictionary.
        """

        with open(json_file, "r", encoding="utf-8") as file:
            tags_dictionary = json.load(file)
        return tags_dictionary

    @staticmethod
    def __set_col_widths(table):
        """
        Helper method that sets the column width of a table of a docx file.
        :param table: table where the column width needs to be set.
        """

        widths = (Cm(1.3), Cm(7), Cm(7))
        for row in table.rows:
            for idx, width in enumerate(widths):
                row.cells[idx].width = width

    @classmethod
    def write_file_to_docx(cls, translation_list_with_AcrossReader, document_name):
        """
        Takes a list containing elements of AcrossEntry that contains of a segment id, a source text and a translation.
        Writes each entry of the given list in a table and saves the file as a docx document.

        :param translation_list_with_AcrossReader: list containing elements of AcrossEntry
        :param document_name: name of the destination file
        """

        document = Document()

        # General Styling
        style = document.styles['Normal']
        font = style.font
        font.name = 'Browallia New'
        font.size = Pt(12)

        # Document title
        document.add_heading('Datei für zweisprachige Überprüfung')

        # Document content
        translation_tuples = list()
        for translation in translation_list_with_AcrossReader:
            translation_tuple = (translation.id, translation.source, translation.translation)
            translation_tuples.append(translation_tuple)

        table = document.add_table(rows=1, cols=3, style="Table Grid")
        table.autofit = False
        hdr_cells = table.rows[0].cells

        # Table header and layout
        header_list = list()
        header_list.append(hdr_cells[0].paragraphs[0].add_run('ID'))
        header_list.append(hdr_cells[1].paragraphs[0].add_run('Ausgangstext'))
        header_list.append(hdr_cells[2].paragraphs[0].add_run('Übersetzung'))

        for header in header_list:
            header.bold = True

        # Table content
        for segment_id, source, translation in translation_tuples:
            row_cells = table.add_row().cells
            row_cells[0].text = str(segment_id)
            row_cells[1].text = source
            row_cells[2].text = translation

        AcrossReader.__set_col_widths(table)
        document.save(document_name)
